[bluestronica.github.io/C](https://bluestronica.github.io/C)

# 포인터 2

### 포인터와 배열의 차이
- sizeof 연산자
  - sizeof(배열)과 sizeof(포인터)는 다른 값을 반환
    - sizeof(배열): 배열의 총 크기를 반환
    - sizeof(포인터): 포인터의 크기를 반환 
- 문자열의 초기화
  - C는 C#이나 java처럼 문자열(string) 자료형이 없다.
  - char 배열을 이용해서 문자열을 표현
  - 문자열이 끝나는 지점을 알려주기 위해 널 문자(null character)를 항상 맨 마지막에 넣어줌
  - 널 문자: 값은 0으로 '\0'으로 표현
- 문자열을 초기화 하는 2가지 방법
  - **배열 표기 : `char day1[] = "Monday";`**
    - 배열에 차례대로 'M','o','n','d','a','y'가 들어간 후 마지막에 '\0'가 들어감
    - 함수 안에서 사용하면 스택 메모리에 저장된다.
      - 함수 안에 있는 `char[]`은 언제나 스택에 생긴다. 
      - 이 배열을 초기화할 때, 넣어주는 문자열인 "Monday"는 `const cahr*`로 데이터 섹션에 들어간다.
      - 스택 메모리에 미리 들어가 있는게 아니라 함수 호출할 때 스택 프레임 잡아주면서 그 공간에 데이터섹션에서 "Monday"라는 걸 복사해온다.
      - 그러니깐 함수의 스택 프레임 생길 때 복사해와 스택에 집어 넣어준다.
      - 그래서 함수 안에서 사용하면 스택 메모리에 저장되고, 혹시 함수 밖에, 즉 파일에 있다면 스택 메모리가 아니라 데이터 섹션에 그냥 들어가서 그걸 쓰게 된다.
      - `int[]`: 지역변수는 스택, 전역변수는 데이터 섹션
  - **포인터 사용 : `char* day2 = "Monday";`**
    - 포인터 변수는 스택에 저장
    - 실제 문자열은 데이터 섹션에 저장
    - 배열 표기와 포인터 사용의 차이점 실제 문자열이 스택에 안 들어온다는 차이점이다.
    - 스택에 저장된 문자열은 수정해도 괜찮지만
    - 데이터 섹션에 저장된 문자열은 수정할 경우 크레쉬 날 수 있다.
    - 그래서 **포인터 사용은 문자열 읽기 전용으로 사용한다.**
- 대입
  - 포인터 변수에 값을 대입할 수 있으나 배열 변수에는 할 수 없음
  ```c
  int* ptr1;
  int* ptr2;
  int arr1[5];
  int arr2[5];
  int x = 5;
  
  ptr1 = arr1;
  arr1 = ptr1;    // 컴파일 오류
  
  ptr1 = &x;
  arr1 = &x;      // 컴파일 오류
  
  ptr1 = ptr2;
  arr1 = arr2;    // 컴파일 오류
  
  // 포인터 변수는 메모리 주소를 저장하는 변수
  // 포인터 변수에 값을 대입한다는 것은 메모리 주소를 대입한다는 것이다.
  ```
- 포인터 산술 연산
  - 포인터는 산술 연산이 가능하지만 배열은 불가능
  - 배열 주소를 증가하거나 감소하고 싶다면
  - **포인터에 배열의 주소를 대입 후** 그 포인터 변수를 증가/감소하면 된다.
  ```c
  ++pointer;
  --pointer;
  
  pointer += 1;
  pointer -= 1;
  
  ++array;        // 컴파일 오류
  --array;        // 컴파일 오류
  
  array += 1;     // 컴파일 오류
  array -= 1;     // 컴파일 오류
  ```
- 포인터와 연산자 우선순위 및 결합법칙 (1)
  - `int num = *p++;` p++가 우선순위
  - `int num = *(p++);` 와 같다.
- 포인터 연산자 평가 및 실행 (1)
  - `int num = *(p++);` 평가 후 실행
    - 1. p++ : p로 평가, 아직 p = p + 1 실행 안 함
    - 2. *(p++)은 *p와 동일 : p의 값(0x104)이 가리키는 주소의 값(134)에 접근
    - 3. = : num에 값(134)을 대입
    - 4. p++ : p = p + 1 실행, 0x108이 p에 저장
- 포인터 연산자 평가 및 실행 (2)
  - `int num = *(++p);`
    - 1. ++p : p = p + 1 실행 후 평가
    - 2. *(++p) : p의 값(0x108)이 가리키는 주소의 값(68)에 접근
    - 3. = : num에 값(68)을 대입
- 포인터 연산자 우선순위 및 결합(2)
  - `int num = ++*p;`
  - `int num = ++(*p);`
    - 1. (*p) : p의 값(0x104)이 가리키는 값(134)에 접근
    - 2. ++ : 접근한 값을 1증가, 134 + 1 = 135
    - 3. = : num에 135를 대입 
- 포인터 연산자 우선순위 및 결합(3)
  - `int num = (*p)++;`
    - 1. (*p) : p의 값(0x104)이 가리키는 값(134)에 접근
    - 2. ++ : 평가하고 대입, 아직 1을 더하진 않음
    - 3. = : num에 134를 대입 
    - 4. ++ : 실행, 134 + 1 = 135, p의 값(0x104)이 가리키는 값(135)
- 조금 더 빠른 배열의 요소 더하기
  - *p++ 이렇게 접근하는게 배열보다 더 빠름
  - 배열은 언제나 첫 주소 + 요소 위치까지의 오프셋
  - 포인터는 이미 다음 주소에 가 있기에 그대로 참조
  ```c
  int sum(int* data, const size_t length)
  {
    int result = 0;
    size_t i;
    
    for (i = 0; i < length; ++i)
    {
      result += data[i];
    }
    
    return result;
    
    // &data[0] + (0 * 4)
    // &data[0] + (1 * 4)
    // &data[0] + (2 * 4)
    // &data[0] + (3 * 4)
    // &data[0] + (4 * 4)
    // 배열은 언제나 첫 주소 + 요소 위치까지의 오프셋
  }
  ```
  ```c
  int sum(int* start, int* end)
  {
    int result = 0;
    int* p = start;
    
    while (p < end)
    {
      result += *p++;
    }
    
    return result;
    
    // p = p + 4    
    // p = p + 4
    // p = p + 4
    // p = p + 4
    // p = p + 4
    // 포인터는 이미 다음 주소에 가 있기에 그대로 참조
  }
  ```
  
### 포인터와 const
- **주소를 보호하는 const 포인터**
  - **`int* const p = &num;`**
  - "p is a const pointer to int"
  - const 변수
    - 생성과 동시에 초기화해야함
    - 초기화 이후 다른 값으로 변경 불가
    - const가 아닌 변수에 대입은 가능
    - `const int 변수`
    - `int* const 변수`
- **그 주소가 가리키는 값을 보호하는 const를 가리키는 포인터**
  - **`const int* p = &num;`**
  - "p is a pointer to int, which is const"
  - 실수가 있을 경우 함수 내에서 뿐만 아니라 전역적으로 문제가 발생
  - **그래서 이게 바로 전의 주소 보호 보다 더 중요!!**
  ```c
  int display_user(const int* id, const char* name)
  {
    int result;
    
    // id를 읽기 전용으로 막 사용
    // name을 읽기 전용으로 막 사용
        
    return result;
  }
  ```
- 두 const의 정리  
  - 주소를 보호하는 const 포인터
    - **`int* const p = &num;`**  
  - 주소가 가리키는 값을 보호하는 cosnt 포인터
    - **`const int* p = &num;`**
  - 주소에 저장되어 있는 값을 보호하는 const가 더 중요함!
- 두 cosnt 합체!
  - **`const int* const p = &num;`**
  - "p is a const pointer to const int"
  - 초기화된 후 절대 바뀌지 않는 변수가 있을 때 정도만 유용할 듯
    - 전역변수, 구조체 멤버 변수
- const 베스트 프랙티스
  - const는 최대한 다 붙이는게 좋음
  - const 캐스팅은 하지 말 것
  
### 포인터의 용도
- 큰 데이터를 함수의 매개변수로 전달할 때
  - 자료가 커질수록 데이터를 복사하는라 시간 낭비함
  - 그래서 배열이 매개변수로 전달될 경우, 첫 번째 요소의 주소를 전달
- 반환 값이 둘 이상일 때
  - c에서는 언제나 하나만 반환해야하기 때문에 return 문으로 불가능
  - 하지만 포인터를 사용하면 함수 안에서 원본을 직접 변경할 수 있음
  - 원본 값을 읽지 않고 그냥 덮어쓰는 거라면 반환이나 마찬가지
- 동적 메모리 할당
  - 함수의 범위에 상관없이 한동안 사용하고자 하는 데이터
  - 동적으로 할당된 메모리는 역시 연속된 메모리 덩어리
  - 따라서 포인터가 적합(배열과 비슷한 이유)
- 그 외...
  - 데이터 구조를 구현할 때
    - 연결 리스트, 트리 등과 같은 데이터 구조에 포인터가 적합
    - 임베디드 프로그래밍 등에서 하드웨어에 있는 메모리에 직접 접근해야 할 때
      - 예: 어떤 하드웨어는 화면을 보여주려면 특정 메모리 위치에 이미지 데이터를 직접 복사해줘야 함

### 포인터와 배열
- **포인터 배열 : 포인터를 저장하는 배열**
  - int를 담는 배열 선언
    - **`int nums[3];`**
  - int*를 담는 배열 선언
    - **`int* num_ptr[3];`**
  ```c
  int nums1[3] = { 11, 22, 33 };
  int nums2[1] = { 99 };
  int nums3[4] = { 88, 36, 99, 77 };

  int* num_ptr[3];
  num_ptr[0] = nums1;
  num_ptr[1] = nums2;
  num_ptr[2] = nums3; 

  // 포인터 배열은 배열의 배열과 비슷한 개념
  ```
- 2차원 배열
```c
void do_magic(int matrix[][10], size_t m)
{
}

int main(void)
{
  int matrix[5][10] =
  {
    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
  };
  do_magic(matirx, 5);
}

// C에서 배열을 매개변수로 전달할 때는 
// 그게 1차원이던 2차원 배열이던
// 그냥 배열의 시작 주소(즉 포인터 하나)가 전달될 뿐이다.
```
  
  
  
  
  
  
  
  
  
  
  
  
  

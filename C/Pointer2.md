[bluestronica.github.io/C](https://bluestronica.github.io/C)

# 포인터 2

### 포인터와 배열의 차이
- sizeof 연산자
  - sizeof(배열)과 sizeof(포인터)는 다른 값을 반환
    - sizeof(배열): 배열의 총 크기를 반환
    - sizeof(포인터): 포인터의 크기를 반환 
- 문자열의 초기화
  - C는 C#이나 java처럼 문자열(string) 자료형이 없다.
  - char 배열을 이용해서 문자열을 표현
  - 문자열이 끝나는 지점을 알려주기 위해 널 문자(null character)를 항상 맨 마지막에 넣어줌
  - 널 문자: 값은 0으로 '\0'으로 표현
- 문자열을 초기화 하는 2가지 방법
  - **배열 표기 : `char day1[] = "Monday";`**
    - 배열에 차례대로 'M','o','n','d','a','y'가 들어간 후 마지막에 '\0'가 들어감
    - 함수 안에서 사용하면 스택 메모리에 저장된다.
      - 함수 안에 있는 `char[]`은 언제나 스택에 생긴다. 
      - 이 배열을 초기화할 때, 넣어주는 문자열인 "Monday"는 `const cahr*`로 데이터 섹션에 들어간다.
      - 스택 메모리에 미리 들어가 있는게 아니라 함수 호출할 때 스택 프레임 잡아주면서 그 공간에 데이터섹션에서 "Monday"라는 걸 복사해온다.
      - 그러니깐 함수의 스택 프레임 생길 때 복사해와 스택에 집어 넣어준다.
      - 그래서 함수 안에서 사용하면 스택 메모리에 저장되고, 혹시 함수 밖에, 즉 파일에 있다면 스택 메모리가 아니라 데이터 섹션에 그냥 들어가서 그걸 쓰게 된다.
      - `int[]`: 지역변수는 스택, 전역변수는 데이터 섹션
  - **포인터 사용 : `char* day2 = "Monday";`**
    - 포인터 변수는 스택에 저장
    - 실제 문자열은 데이터 섹션에 저장
    - 배열 표기와 포인터 사용의 차이점 실제 문자열이 스택에 안 들어온다는 차이점이다.
    - 스택에 저장된 문자열은 수정해도 괜찮지만
    - 데이터 섹션에 저장된 문자열은 수정할 경우 크레쉬 날 수 있다.
    - 그래서 **포인터 사용은 문자열 읽기 전용으로 사용한다.**
- 대입
  - 포인터 변수에 값을 대입할 수 있으나 배열 변수에는 할 수 없음
  ```c
  int* ptr1;
  int* ptr2;
  int arr1[5];
  int arr2[5];
  int x = 5;
  
  ptr1 = arr1;
  arr1 = ptr1;    // 컴파일 오류
  
  ptr1 = &x;
  arr1 = &x;      // 컴파일 오류
  
  ptr1 = ptr2;
  arr1 = arr2;    // 컴파일 오류
  
  // 포인터 변수는 메모리 주소를 저장하는 변수
  // 포인터 변수에 값을 대입한다는 것은 메모리 주소를 대입한다는 것이다.
  ```
- 포인터 산술 연산
  - 포인터는 산술 연산이 가능하지만 배열은 불가능
  - 배열 주소를 증가하거나 감소하고 싶다면
  - **포인터에 배열의 주소를 대입 후** 그 포인터 변수를 증가/감소하면 된다.
  ```c
  ++pointer;
  --pointer;
  
  pointer += 1;
  pointer -= 1;
  
  ++array;        // 컴파일 오류
  --array;        // 컴파일 오류
  
  array += 1;     // 컴파일 오류
  array -= 1;     // 컴파일 오류
  ```
- 포인터와 연산자 우선순위 및 결합법칙
  - `int num = *p++;` p++가 우선순위
  - `int num = *(p++);` 와 같다.
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

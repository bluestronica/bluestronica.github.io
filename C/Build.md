[bluestronica.github.io/C](https://bluestronica.github.io/C)

# 빌드 단계

### C프로그램의 빌드 과정
- 빌드는 사람이 읽기 쉬운 소스코드를 기계어 명령어로 변화하는 과정 그리고 그 명령어들을 모아 기계에서 실행 가능한 실행파일로 만드는 과정
- C의 빌드는 4단계로 나뉘어져 있다.
  - 전처리(preprocessing)
  - 컴파일(compilation)
  - 어셈블(assembling)
  - 링크(linking)
1. 소스코드
  - 두 종류의 소스코드파일 : .h와 .c
    - 헤더 파일(.h)
      - 여러 소스코드 파일에 공통적으로 필요한 것들을 저장해두는 파일
      - 내용물 : 함수선언, 매크로, extern 변수 선언 등
      - #include로 포함함 (예: #include "adder.h")
      ```c
      // adder.h
      int add(const int a, const int b);
      ```
      - 헤더 파일을 사용하면 함수 선언을 여러 C파일들과 공유가능
      - `#inlcude <>`
        - 시스템 경로에서만 헤더 팡리을 검색
      - `#include ""`
        - 현재 작업 중인 디렉터리에서 헤더파일을 먼저 검색한 뒤 없으면 시스템 경로를 검색
        - 개발자가 구현한 헤더 파일들을 inlcude할 때 사용
    - C파일(.c)
      - 실제 프로그램을 돌게 하는 로직코드를 저장해 두는 파일
      - 내용물 : 함수정의(=함수 구현), 매크로, 전역 변수 등
      ```c
      // adder.c
      #include "adder.h"
      
      int add(const int a, const int b)
      {
        return a + b;
      }
      ```
      ```c
      // main.c
      #include "adder.h"
      
      int main(void)
      {
        const int res = add(1, 2);
        return 0;
      }
      
      // main -> h -> c
      // main이 h를 가지고 h를 가진 c
      ```
2. 전처리기
  - 입력: c파일 하나
  - 주석 제거
  - 매크로를 복붙 확장함
  - 인클루드 파일들을 복붙확장 함(헤더 파일 속에 있는 내용을 복사해서 가져다 붙임)
  ```c
  // stdio.h의 코드가 여기에 붙음 (약 2473줄)
  
  int main(void)
  {
    printf("Hello!\n");
    return 0;
  }
  ```
  - 출력: 확장된 소스코드
3. 확장된 소스코드(트랜스레이션 유닛)
  - 컴파일의 기본 단위인 트랜슬레이션 유닛
4. 컴파일러
  - 출력 : 어셈블리어 코드
    - main.c의 트랜슬레이션 유닛을 컴파일러는 어셈블리어 코드로 출력
5. 어셈블리 코드
6. 어셈블러
  - 출력 : 오브젝트 코드
7. 오브젝트 코드
  - 기계가 곧바로 이해 가능한 기계 코드(machine code)
  - 기계어라고도 한다.
  - 즉, 이진코드  
8. 링커
  - 입력 : 모든 오브젝트 코드들
  - 링커는 모든 오브젝트 코드들을 모아다 구멍을 메꾼 뒤 실행파일로 저장
  - 출력 : 최종 실행파일(.exe, .out)
9. 머신 코드 실행파일(.exe, .out)

- 라이브러리(library) 빌드
  - 빌드 결과가 실행팡리이 아니라 라이브러리 파일이 나오게 할 수 있다.
  - 라이브러리(library)
    - 함수 등을 기계어로 변환 후 파일 하나로 저장해 놓은 것
    - 나중에 다른 .c 파일에서 이 기능이 필요할 때 같이 링크해서 쓸 수 있음
    - 정적(static)라이브러리와 동적(dynamic)라이브러리 두 종류가 있다.
  - 정적 라이브러리와 링크
    - 정적 라이브러리와 링크하는 것을 정적 링킹이라고 한다.
    - 라이브러리 안에 있는 기계어를 최종 실행파일에 가져다 복사함
    - 정적 라이브러리 + 오브젝트 파일 `=> 링크` 실행파일
    - 동적 링킹에 비해
      - 실행파일의 크기가 커짐
      - 메모리를 더 잡아먹을 수 잇음
      - 실행 속도가 빠름
- 동적 라이브러리와 링크
  - 동적 라이브러리와 링크하는 것을 동적 링킹이라고 한다.
  - 실행파일 안에 여전히 구멍을 남겨두는 방법
  - 실행파일을 실행할 때 실제로 링킹이 일어남
    - 이 링키은 실행 중에 운영체제가 해 줌
  - C# 등에서 .dll(dynamic link library) 파일을 의미한다.
  - 정적 링킹에 비해
    - 실행파일 크기가 작다
    - 여러 실행팡리이 동일한 라이브러리를 공유할 수 있다. (메모리 절약)
    - 여러 실행파일이 이름은 같지만 버전이 다른 동적 라이브러리를 사용한다면 크래시 난다.
- 분할 컴파일
  - 2개 이상의 .c 파일을 개별적으로 컴파일해서 오브젝트 파일을 만듦
  - 오브젝트 파일들을 서로 연결시켜(링크해서) 실행파일을 만듦
- **extern 키워드**
  - **다른 파일에 있는 전역변수에 접근하려면 extern 키워드를 사용**
- 전역 변수의 문제
  - 확실히 문제는 있음
    - extern 사용하면 아무데서나 다 확인 가능하고
    - 심지어는 자기 마음대로 내 파일 안의 변수를 바꿔버림
  - 다른 사람에게 내 전역 변수를 못쓰게 하려면
    - 내 파일 안에서만 쓰려면 
    - 전역 변수 만들 때 static 키워드를 붙여주면 됨
- **static 키워드**
  - **다른 파일에서 전역 변수에 접근 못하게 막는 법**
  - 이 변수의 범위가 파일로 한정됨
  - 흔히 정적 변수라고 한다.
  - 여전히 전역 변수로 프로그램 실행 동안 실제 공간을 계속 차지하고 있음
  - static 변수를 다른 파일에서 접근하려고 하면 링커 오류
- 함수안에서 static의 또 다른 의미
  - static이 없으면 지역변수이고 함수 반환 시 그 변수도 사라짐
  - static을 쓰면 개념상 전역변수이다.
    - 허나 그 함수 안에서만 접근 가능
    - 즉, 함수가 반환돼도 여전히 값은 저장되어 있음
- 함수 앞에 static 키워드를 넣으면 외부로부터의 접근을 막을 수 있다.
- 실제 컴파일러 구현
  - static 변수는 함수의 스택 프레임이 아닌 전역적인 데이터 섹션에 들어간다.
  - 프로그램 시작할 때 그 값을 초기화 한다.
  - 함수가 호출될 때는 어떤 초기화도 일어나지도 않는다.
    - 이미 프로그램 시작시에 초기화가 되었으니,
    - 처음 함수 호출할때는 그 초기화 된 값이 그대로 유지되어 있다.
- 정리
  - .c와 .h 파일 정리
    - .h 헤더 파일에는 선언만 들어간다.
      - 함수 선언
      - 전역 변수 extern 선언
    - .c 파일에는 정의가 들어간다.
      - 함수 정의
      - 전역 및 정적 변수 정의
    
  

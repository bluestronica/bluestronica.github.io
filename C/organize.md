### 목표 : 포인터(Linked-list), 디버깅 가능, 함수포인터 + Callback 구조


#### 데이터가 메모리에 저장되는 방식
- C에서 다루는 데이터(-, +, 정수, 실수, 문자, 문자열)가 컴파일 된 후에는 **2진수 표기법으로 컴퓨터 안에서 값이 저장**되어 표현된다.
- 데이터의 값을 바꿀 수 없는 **상수의 형태**와 값을 바꿀 수 있는 **변수의 형태**가 있다.

#### 기본 문법 정리
- **unsigned int, int 구분해서 부호 사용**
  - int는 signed int이다. 그래서 부호 signed는 생략하고 int로 쓴다.
```C
  int signed_int = -10000;
  unsigned int unsigned_int = 234545;
```
- **char(최소 8비트인 정수형)**
  - 문자 하나를 표현할 수 있는 최소 8비트인 정수형
  - ASCII는 총 128개의 문자를 표현(저장된 값은 0~127인 숫자)
```C
  char ch_a = 'a';  // 값은 정수 97이 저장되고 출력은 문자 'a'가 출력된다.
  char cha_b = 98;  // 출력은 값인 정수 98을 나타내는 문자 'b'가 출력된다.

  // char은 값이 정수이니 char 타입끼리 덧셈, 뺄셈이 가능하며
  // 그것을 이용해 문자 '1'을 정수 1로 나타낼수 있다.
```

- 정수형 타입 short (최소 16비트)
  - int 대신 short를 사용할 경우 성능이 느려질 수도 있다.

- **정수형 타입 int (기본 정수 32비트)**
```C
  // 비트 32개로 표현 가능햔 정수의 숫자의 범위

  // sigend 부호있는 정수 이므로 숫자의 범위는 음수, 0, 양수 
  int num1 = -2137483648;
  int num2 = 0;
  int num3 =  2137483647;

  // unsigend 부호 없는 정수 이므로 숫자의 범위는 0, 양수
  unsigend int num1 = 0;
  unsigend int num2 = 4294967295;
```

- 정수형 타입 long (32비트)
  - int가 16비트일 때 2배 큰 자료형이 필요했다.
  - 다른 언어에서는 long이 보통 64비


- **실수형 타입 float (32비트)**
  - IEEE 754 single(32비트)
    - 지수의 길이 8비트
    - 가수의 길이 23비트
    - 소수 부분 6자리까지 오차없이 표현할 수 있다.
```C
  float num1 = 3.1415926535897932;  
  printf("변수 num1에 저장된 값은 %.20f\n", num1);

  // 변수 num1에 저장된 값은 3.14159274101257324219
  // 변수 num1에는 소수점 6자리까지만 정확한 값이 저장되어 있고,
  // 소수점 7자리부터는 틀린 값이 저장되어 있다.
```

- **실수형 타입 double (64비트)**
  - IEEE 754 double(64비트)
    - 지수의 길이 11비트
    - 가수의 길이 52비트
    - 소수 부분 15자리까지 오차없이 표현할 수 있다.
```C
  double num1 = 3.1415926535897932;  
  printf("변수 num1에 저장된 값은 %.20f\n", num1);

  // 변수 num1에 저장된 값은 33.14159265358979311600
  // 변수 num1에는 소수점 15자리까지만 정확한 값이 저장되어 있고,
  // 소수점 16자리부터는 틀린 값이 저장되어 있다.
```

- **코딩 표준: 참, 거짓은 1과 0을 반환한다.**
```C
  // C에서는 true, false를 사용하지 않는다.
  // 0이면 false, 0이 아니면 true
  // 하드웨어에서도 실제 bool이 없음. 0이냐 아니냐만 있다

  // 참이나 거짓을 반환해야하는 함수의 경우
  int is_student(const int id)
  {
    if( /* 조건 */) {
      return 1;  // 참일 때는 1 반환
    }
    return 0:  // 거짓일 때는 0 반환
  }
```

- if문과 불 표현식
```C
  // 숫자를 if문의 조건식에 넣어도 곧바로 판단이 가능
  float num = 0.0f;

  if (num) {  // false : 0;
    printf("%f\n", num);
  }

  float num = 3.14f;

  if (num) {  // true : 3.14f;
    printf("%f\n", num);
  }

  // 메모리 주소(포인터)나 float형도 마찬가지로
  // 모든 비트패턴이 0이면 false, 아니면 true
```

- **열거형(enum)**
C에서의 열거형은 그냥 정수에 별명 붙이는 수준이다.
```C
enum day { DAY_MONDAY, DAY_TUESDAY, DAY_WEDNESDAY. /* 생략 */ };
enum month { MONTH_JANUARY, MONTH_FEBRUARY, MONTH_MARCH /* 생략 */ };

enum day hump_day = DAY_WEDNESDAY;  // 정수 2 입력
enum month birth_month = hum_day;  /* 컴파일이 됨. 정수 2 입력 */

// 정수에 별명 붙이는 수준 즉, int와 섞어서 사용 가능하다.
```
- ** 올바른 변수 선언 위치**
```C
int main(void)
{
  int num1 = 10;
  int num2 = 1234;
  int result1;    // 변수 선언은 반드시 블력 시작에서 해야한다.
  int result2;    // 코드 중간에 사용하는 변수는
                  // 블록 시작에서 선언하고 대입

  print("변수 선언 위치"/n);

  result1 = add(num1, num2);  // 컴파일 오류
  result2 = add(num1, num2);  // 컴파일

  return 0;
}
```

- C에서 새로 만나는 연산자
  - **sizeof()**
    - 피연산자의 크기를 **바이트로 반환**해주는 연산자
    - **함수가 아니다!!!!**
    - 실행 중이 아니라 **컴파일 중에 평가**된다.
    - **char 형을 넣으면 반드시 1이 반환**
    - 연산자가 반환하는 값은 **부호 없는 정수형 상수**로 **size_t 형**
  - 역 참조 연산자 **`*`**
  - 주소 연산자 **`&`**
  - 구조체와 공용체 멤버 접근자 **`.`**과 **`->`**
    
- size_t
  - 부호 없는 정수형이나 실제 데이터형이 아니다.
  - `_t`는 typedef를 했다는 힌트
  - 보통은 unsigend int를 사용
    - 즉, 64비트 인 경우 unsigend __int64(64bit)
    - 32비트 인 경우 unsigend int(32bit)
  - 반목분이나 배열에 접근할 때 사용(크기를 나타내기 위해)
  - size_t와 -1
    - signed int -1과 unsigined int 4,294,967,295는 같은 비트패턴을 가진다.

    |signed|4|2|1|unsigned|
    |---:|:---|:---|:---|:---|
    |0|0|0|0|0|
    |1|0|0|1|1|
    |2|0|1|0|2|
    |3|0|1|1|3|
    |-4|1|0|0|4|
    |-3|1|0|1|5|
    |-2|1|1|0|6|
    |-1|1|1|1|7|
      
- **case에 사용간으한 데이터형**
  - C는 정수형만 가능
  - int, char, enum

- **코딩 표준 : fall-through를 명시적으로 표기**
```C
  // 의도를 가지고 'break;'를 사용하지 않을 경우
  // /* intentional fallthrough */
  // 위 주석을 반드시 붙인다.

  enum fruit { FRUIT_APPLE, FRUIT_MANGO };
  enum fruit fruit = FRUIT_APPLE;

  switch (fruit) {
  case FRUIT_APPLE:
    printf("Breakfast\n");
    /* intentional fallthrough */
  case FRUIT_MANGO:
    printf("Lunch\n");
    break;
  default:
    printf("Unknown fool\n");
    break;
  }
```

- 반목문 실행 도중 탈출하려면 **break;**
- 다음 회차로 넘어 가려면 **continue;**

- **코딩 표준 : while 문**
```C
// 조건식은 bool형 대신 1, 0을 반환
// '== 0' 혹은 '!= 0'을 사용한다.

int day = 5;
while (day-- != 0) {  // 좋은 예
  printf("%d\n", day);
}
``` 

- **함수**
  - C의 함수는 기본적으로 모두 전역(global)함수다.
  - 함수 오버로딩이 없다. 함수 명을 다르게 만들어야 한다.
  - 함수를 사용하기 전에 함수 선언
  - 함수 선언과 함수 정의
    - 함수 선언과 정의를 분리
    - 함수 선언과 정의가 하나
  - 전방 선언의 작동 원리
    - 컴파일러가 함수의 이름과 반환형 그리고 매개변수를 알 수 있지만 실제 구현한 코드는 비워 놓는다.
      - 함수 선언
    - 컴파일 다음 단계인 링크(link) 단계에 실제 코드(함수 정의) 위치를 찾아서 비워 놓은 곳을 메꾼다.(실제 구현한 위치의 주소를 넣어 준다.)
  - 함수 매개변수의 평가 순서는 컴파일러에 따라 평가 순서가 달라질 수 있다.
    - 한 줄에 있는 함수 호출 순서에 의존해서 코드 작성하지 않는다.
  - 한 표현식에서 같은 변수를 여러 번 바꾸지 않는다.

-  **평가 순서**
  -  한 줄에 있는 피연산자들은 기본적으로 평가 순서가 보장 안 된다.
  -  다만, &&와 ||의 경우 왼쪽 피연산자를 먼저 실행
    -  ||는 왼쪽 피연산자가 참이면 오른쪽 연산자 평가 안 함
      -  ` hp++ || mp++ `
    -  &&는 왼쪽 피연산자가 거짓이면 오른쪽 연산자 평가 안함
      -  ` exp++ && atk++ `
  -  삼항 연산자(?:)도 평가 순서 보장함

- 범위(scope)
  - 블록 범위
    - 중괄호`{}` 안에 선언한 것들은 그 블록 안에서만 사용 가능
    - 블록 안에 또 다른 블록을 넣을 수도 있다
  - 파일 범위
    - 어떤 블록이나 매개변수 목록에도 안 속하고 파일 안에 있는 것
    - 파일 범위에 있는 변수는 다른 소스코드 파일에 링크 가능하며 프로그램 실행 동안 공간을 차지한다. 즉, 스택의 메모리에 들어가 있는 아니라 데이터 섹션에 들어간다.
    - 이게 바로 **전역 변수**이다.
  - 함수 범위
    - 유일한 예: 레이블(label)
    - goto 같은 데서 쓰는 것
  - 함수 선언 범위
    - 함수 선언의 매개변수 목록에 있는 것은 그 목록 안에서 접근 가능
```C
  void do_something(
    double vlaue,                     // 함수 선언 범위
    char array(10 * sizeof(vlaue)]    // value는 첫 번째 매개변수
  };
```

- goto문





#### 포인터 완전 이해
- 배열
- 포인터
- 함수에 배열, 포인터 자유자재 사용

#### C-Sytle 문자열, 입출력 및 콘솔 입력과 파일 입출력

#### 구조체, 함수포인터 비동기 파일 입출력

#### 스택 메모리의 동작법 이해
- 레지스터
- 스택
- 힙
- 동적 메모리
- 다중 포인터

#### 나만의 라이브러리 만들기
- C 표준 라이브러리의 문자열 함수 구현

#### 비트패턴 및 진법 변환을 자유자재 사용
- IEEE 754 부동 소수점 구현

#### Type-Generic 함수 만들기
- 정적 어서트
- 메모리 정렬
- 멀티스레딩

#### 자료구조'
- 선형
  - 단일연결 리스트, 2중 연결 리스트
  - LInked list 기반 stack, queue 구현
- 비선형
  - 2진트리
  - AVL
  - B-Tree

#### 프로젝트
- 주소록 구현
  - 연결리스트
  - 2진트리
  - AVL
  - B-Tree
  - 2차메모리(파일)에 데이터가 있을 때 Index를 B-Tree형태로 한다.
  - 조건 검색 추가
  - B-Tree로 데이터를 10만건 집어 넣기
  - 조건 검색(SQL 문법 Select 구문 지원)으로 10건 뽑아내기
  - 뽑은 것은 In Memory 처리가 되도록 개선
  - 이 모든걸 C++로 작성

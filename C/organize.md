### 목표 : 포인터(Linked-list), 디버깅 가능, 함수포인터 + Callback 구조


#### 데이터가 메모리에 저장되는 방식
- C에서 다루는 데이터(-, +, 정수, 실수, 문자, 문자열)가 컴파일 된 후에는 **2진수 표기법으로 컴퓨터 안에서 값이 저장**되어 표현된다.
- 데이터의 값을 바꿀 수 없는 **상수의 형태**와 값을 바꿀 수 있는 **변수의 형태**가 있다.

#### 기본 문법 정리
- **unsigned int, int 구분해서 부호 사용**
  - int는 signed int이다. 그래서 부호 signed는 생략하고 int로 쓴다.
```C
  int signed_int = -10000;
  unsigned int unsigned_int = 234545;
```
- **char(최소 8비트인 정수형)**
  - 문자 하나를 표현할 수 있는 최소 8비트인 정수형
  - ASCII는 총 128개의 문자를 표현(저장된 값은 0~127인 숫자)
```C
  char ch_a = 'a';  // 값은 정수 97이 저장되고 출력은 문자 'a'가 출력된다.
  char cha_b = 98;  // 출력은 값인 정수 98을 나타내는 문자 'b'가 출력된다.

  // char은 값이 정수이니 char 타입끼리 덧셈, 뺄셈이 가능하며
  // 그것을 이용해 문자 '1'을 정수 1로 나타낼수 있다.
```

- 정수형 타입 short (최소 16비트)
  - int 대신 short를 사용할 경우 성능이 느려질 수도 있다.

- **정수형 타입 int (기본 정수 32비트)**
  - int로 표현 가능한 숫자의 범위
```C
  // sigend 부호있는 정수 이므로 숫자의 범위는 음수, 0, 양수 
  int num1 = -2137483648;
  int num2 = 0;
  int num3 =  2137483647;

  // unsigend 부호 없는 정수 이므로 숫자의 범위는 0, 양수
  unsigend int num1 = 0;
  unsigend int num2 = 4294967295;
```

- 정수형 타입 long (32비트)
  - int가 16비트일 때 2배 큰 자료형이 필요했다.
  - 다른 언어에서는 long이 보통 64비


- **실수형 타입 float (32비트)**
  - IEEE 754 single(32비트)
    - 지수의 길이 8비트
    - 가수의 길이 23비트
    - 소수 부분 6자리까지 오차없이 표현할 수 있다.
```C
  float num1 = 3.1415926535897932;  
  printf("변수 num1에 저장된 값은 %.20f\n", num1);

  // 변수 num1에 저장된 값은 3.14159274101257324219
  // 변수 num1에는 소수점 6자리까지만 정확한 값이 저장되어 있고,
  // 소수점 7자리부터는 틀린 값이 저장되어 있다.
```

- **실수형 타입 double (64비트)**
  - IEEE 754 double(64비트)
    - 지수의 길이 11비트
    - 가수의 길이 52비트
    - 소수 부분 15자리까지 오차없이 표현할 수 있다.
```C
  double num1 = 3.1415926535897932;  
  printf("변수 num1에 저장된 값은 %.20f\n", num1);

  // 변수 num1에 저장된 값은 33.14159265358979311600
  // 변수 num1에는 소수점 15자리까지만 정확한 값이 저장되어 있고,
  // 소수점 16자리부터는 틀린 값이 저장되어 있다.
```

- **코딩 표준: 참, 거짓은 1과 0을 반환한다.**
```C
  // C에서는 true, false를 사용하지 않는다.
  // 0이면 false, 0이 아니면 true
  // 하드웨어에서도 실제 bool이 없음. 0이냐 아니냐만 있다

  // 참이나 거짓을 반환해야하는 함수의 경우
  int is_student(const int id)
  {
    if( /* 조건 */) {
      return 1;  // 참일 때는 1 반환
    }
    return 0:  // 거짓일 때는 0 반환
  }
```

- **열거형(enum)**
C에서의 열거형은 그냥 정수에 별명 붙이는 수준이다.
```C
enum day { DAY_MONDAY, DAY_TUESDAY, DAY_WEDNESDAY. /* 생략 */ };
enum month { MONTH_JANUARY, MONTH_FEBRUARY, MONTH_MARCH /* 생략 */ };

enum day hump_day = DAY_WEDNESDAY;  // 정수 2 입력
enum month birth_month = hum_day;  /* 컴파일이 됨. 정수 2 입력 */

// 정수에 별명 붙이는 수준 즉, int와 섞어서 사용 가능하다.
```
- ** 올바른 변수 선언 위치**
```C
int main(void)
{
  int num1 = 10;
  int num2 = 1234;
  int result1;    // 변수 선언은 반드시 블력 시작에서 해야한다.
  int result2;    // 코드 중간에 사용하는 변수는
                  // 블록 시작에서 선언하고 대입

  print("변수 선언 위치"/n);

  result1 = add(num1, num2);  // 컴파일 오류
  result2 = add(num1, num2);  // 컴파일

  return 0;
}
```

- C에서 새로 만나는 연산자
  - **sizeof()**
    - 피연산자의 크기를 **바이트로 반환**해주는 연산자
    - **함수가 아니다!!!!**
    - 실행 중이 아니라 **컴파일 중에 평가**된다.
    - **char 형을 넣으면 반드시 1이 반환**
    - 연산자가 반환하는 값은 **부호 없는 정수형 상수**로 **size_t 형**
  - 역 참조 연산자 **`*`**
  - 주소 연산자 **`&`**
  - 구조체와 공용체 멤버 접근자 **`.`**과 **`->`**
    
- size_t
  - 부호 없는 정수형이나 실제 데이터형이 아니다.
  - `_t`는 typedef를 했다는 힌트
  - 보통은 unsigend int를 사용
    - 즉, 64비트 인 경우 unsigend __int64(64bit)
    - 32비트 인 경우 unsigend int(32bit)
  - 반목분이나 배열에 접근할 때 사용(크기를 나타내기 위해)
  - size_t와 -1
    - signed int -1과 unsigined int 4,294,967,295는 같은 비트패턴을 가진다.
    - 부호 있는 0  1  2  3 -4 -3 -2 -1  (-1)
    - 부호 없는 0  1  2  3  4  5  6  7  (7)

      
#### 포인터 완전 이해
- 배열
- 포인터
- 함수에 배열, 포인터 자유자재 사용

#### C-Sytle 문자열, 입출력 및 콘솔 입력과 파일 입출력

#### 구조체, 함수포인터 비동기 파일 입출력

#### 스택 메모리의 동작법 이해
- 레지스터
- 스택
- 힙
- 동적 메모리
- 다중 포인터

#### 나만의 라이브러리 만들기
- C 표준 라이브러리의 문자열 함수 구현

#### 비트패턴 및 진법 변환을 자유자재 사용
- IEEE 754 부동 소수점 구현

#### Type-Generic 함수 만들기
- 정적 어서트
- 메모리 정렬
- 멀티스레딩

#### 자료구조'
- 선형
  - 단일연결 리스트, 2중 연결 리스트
  - LInked list 기반 stack, queue 구현
- 비선형
  - 2진트리
  - AVL
  - B-Tree

#### 프로젝트
- 주소록 구현
  - 연결리스트
  - 2진트리
  - AVL
  - B-Tree
  - 2차메모리(파일)에 데이터가 있을 때 Index를 B-Tree형태로 한다.
  - 조건 검색 추가
  - B-Tree로 데이터를 10만건 집어 넣기
  - 조건 검색(SQL 문법 Select 구문 지원)으로 10건 뽑아내기
  - 뽑은 것은 In Memory 처리가 되도록 개선
  - 이 모든걸 C++로 작성

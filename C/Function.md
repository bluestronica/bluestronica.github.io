[bluestronica.github.io/C](https://bluestronica.github.io/C)

# 기본문법 2

### 함수(Function)
- **함수 선언**
  - 함수의 구현체 없이 함수 원형만 선언해 주는 것
    - 함수의 이름
    - 반환형
    - 매개변수들의 자료형
  - 위치
    - 함수를 사용하기 전에 그 함수를 선언
    - 보통 파일의 제일 위에
- **함수 정의**
  - 실제로 함수를 구현해 놓은 것
- **함수 선언과 정의를 분리**
```c    
#include <stdio.h>

void foo(void); // 함수 선언; 전방 선언

int main(void)
{
  foo();
  getchar();
  return 0;
}

void foo(void)  // 함수 정의
{
  printf("foo called");
}
```
- **함수 선언과 정의가 하나**
```c    
#include <stdio.h>

void foo(void)  // 함수 정의(+선언)
{
  printf("foo called");
}

int main(void)
{
  foo();
  getchar();
  return 0;
}
```
- 전방 선언의 작동 원리
  - 컴파일러가 함수의 이름과 반환형 그리고 매개변수를 알 수 있음. 
  - 실제 어디로 가서 코드를 찾아야 하는지 모르니 구멍으로 남기고,
  - 컴파일 다음 단계인 링크 단계에서 실제 코드 위치를 찾아서 그 비워진 자리에 구현부의 주소를 넣어준다.
  
### 평가 순서
- 표준에 따르면, 함수 매개변수의 평가 순서는 명시되어 있지않음 즉, 컴파일러에 따라 평가 순서가 달라질 수 있음
```c
printf("%d, %d\n", add(num1, num2), subtract(num1, num2));

// add()와 subtract() 누가 먼저 호출되는지 보장 못함.
```
- 한 함수의 매개변수들이 동일한 변수를 수정할 경우, 결과가 정의되지 않음
```c
add(++i, ++i);        // 어떤 일이 일어날지 정의되지 않음
add(i = -1, i = -1);  // 어떤 일이 일어날지 정의되지 않음
add(i, i++);          // 어떤 일이 일어날지 정의되지 않음
```
- 한 줄에서 같은 변수를 여러 번 수정하면 정의되지 않는 결과
```c
i = ++i + i++;    // 어떤 일이 일어날지 정의되지 않음
i = i++ + 1;      // 어떤 일이 일어날지 정의되지 않음
array[i] = i++;   // 어떤 일이 일어날지 정의되지 않음
```
- 연산자 우선순위와 평가 순서
  - 연산자 우선순위와 평가 순서는 서로 아무 연관이 없음
  ```c
  int result = add(num1, num2) + subtract(num1, num2) * divide(num1, num2);

  // 연산자 우선순위 *이 +보다 높으므로 
  // subtract * divide 먼저 실행할 것이라고 생각하겠지만
  // 평가 순서에서 무엇이 먼저 결과 값이 나올지 모르기 때문에
  // add 값과 subtract 값이 먼저 도출되면
  // 결과 값이 다르게 나올 수도 있다.
  ```
- &&와 ||는 평가 순서를 강제하는 연산자
  - 논리 연산자 &&과 ||의 경우 왼쪽 피연산자를 먼저 실행
    - 왼쪽 피연산자의 평가만으로 오른쪽 피연산자를 평가 안 할수도 있음
    ```c
    hp++ || mp++  
    // 왼쪽 피연산자가 참이면 오른쪽 연산자 평가 안함

    exp++ && atk++
    // 왼쪽 피연산자가 거짓이면 오른쪽 연산자 평가 안함
    ```
- 정리
  - **한 줄에 있는 피연산자들은 기본적으로 평가순서가 보장 안 된다고 생각하자!**
  - 그리고 || 와 && 평가 순서 보장
  - 삼항 연산자 (?:)도 평가 순서 보장. if/else를 줄여 써 놓은 거라 생각하면 된다.
  - ;도 보장
  - 함수를 실제 실행하기 전에 모든 매개변수도 평가 됨
  
### 범위(scope)
- 블럭범위
  - 중괄호{} 안에 선언한 것들은 그 블록 안에서만 사용가능 
- 파일범위
  - 어떤 블록이나 매개변수 목록에도 안 속하고 파일 안에 있는 것
    ```c
    #include <stdio.h>
    
    static int s_num = 1024;  // 파일 범위에 있는 변수
    
    int add(int op1, int op2);
    
    int main(void)
    {
      s_num = add(10, 30);
      
      return 0;
    }
    ```
  - 파일범위에 있는 변수는 다른 소스코드 파일에서 링크 가능
  - 프로그램 실행 동안 공간 차지
  - 즉, 스택 메모리에 들어가는게 아니고 이들은 **데이터 섹션**에 들어간다.
  - 이게 바로 **전역 변수**이다.
- 함수범위
  - 유일한 예: 레이블(label)
  - goto 같은 데서 쓰는 것
- 함수 선언범위
  - 함수 선언의 매개변수 목록에 있는 것은 그 목록 안에서 접근가능 
  - 많이 쓸 일은 없음
  - 다음과 같은 예는 괜찮음
  ```c
  void do_someting
  (
    double value,                     // 함수 선언 범위
    char array[10 * sizeof(value)]    // value는 첫 번째 매개변수
  ); 
  ```

### const 베스트 프랙티스
- 기본적으로 모든 변수에 const를 붙이자
- 정말 값 변경이 필요한 변수에만 const를 생략하자.
```c
int calculate_rist(const int id)    // const를 붙여 값 변경 못하게 막음
{
  int age = db_get_age(id);
  int amount;
  
  // 코드 천 줄
  
  id *= 2;   // 컴파일 오류가 난다. 수정 못하게 막음.
  
  // 코드 천 줄
  
  amount = db_get_deposit_amount(id);
  
  // age, amount 등등을 이용해서 위험 산정
  int risk
  return risk;
}
```

### 배열(array)
- 스택(stack) 메모리
  - 우선 자료구조인 스택이랑 헷갈리지 말 것
  - 둘 다 작동방법이  동일해서 LIFO(last in first out) 스택이란 이름을 쓸 뿐이다.
  - **각 함수에서 사용하는 지역 변수 등을 임시적으로 저장하는 공간**
  - 스택 메모리의 크기는 프로그램 빌드 시에 결정된다.
  - 스택 메모리의 위치는 실행 시에 결정된다.
  - 함수가 호출될 때마다 그 함수에서 필요한 공간을 스택에서 떼어줬다가 그 함수가 반환하면 그냥 흔들어 지워버리는 개념(실제 지우진 않음)
  - 기본 자료형 변수는 스택 메모리를 차지한다.
    - 모든 기본 자료형 변수(char, int, float)를 new 없이 사용할 수 있었던 이유가 바로 스택 메모리에 할당됐기 때문이다.
    - 기본형 자료형을 함수 매개변수로 전달하면 스택에 복사본을 만든다. -> 이게 바로 값형
    - 스택 메모리를 빌리고 반환할 때마다 언제나 빈공간없이 차곡차곡 쌓여 있다.
    - new로 만든 데이터는 힙(heap)메모리에 할당된다
      - 이 경우 메모리에 구멍이 숭숭 뚫릴 수 있다.
  - **배열도 스택 메모리에 들어간다.**
- sizeof()
```c
int values[30];
size_t array_size = sizeof(values);   // 120

// sizeof(values)는 values 배열이 차지하는 총 바이트 수를 반환한다.
// 그 이유는 이 배열이 스택에서 몇 바이트를 차지하는지 컴파일 중에 알기 때문이다.
```
- 배열의 요소 개수 구하는 방법
  - 방법 1
  ```c
  const size_t num_vals = sizeof(values) / sizeof(values[0]);
  ```
  - 방법 2
  ```c
  // 함수 밖에서
  #define ARRAY_LENGTH(arr) sizeof(arr) / sizeof(arr[0]))
  
  // 매크로 함수 사용
  const size_t num_vals2 = ARRAY_LENGTH(values);
  ```
- 배열을 매개변수로 전달할 때는 실제 모든 요소를 스택에 넣지 않음
  - 그 대신 그 배열의 시작 위치(주소)를 스택에 넣어 줌
  - 이 주소의 크기 = 포이터 데이터형의 크기
  - 32비트 플랫폼에서는 4바이트
  - 64비트에서는 8바이트
```c
int do_something(int data[]);

int main(void)
{
  int values[3];  // {1, 2, 3}
  do_something(values);
}
```
- 그래서 원본 배열이 바뀐다.
```c
void process(int num[5])  // 프로그래머가 읽기 편하라고 [5]를 써준 것
{                         // 컴파일하면 void process(int nums[]) 와 동일
  size_t i;
  for (i = 0; i < 5; ++i)
  {
    nums[i] *= 2;   // 배열 nums[0] 시작 주소로 바로 접근해서 값을 변경하기 때문에
  }                 // 원본이 바뀐다.
}
```
- **매개변수 배열은 시작 주소로 전달되기에 배열의 길이를 알 방법이 없다.**
  - 그래서 아까와 같은 함수는 이렇게 작성해야 한다.
  ```c
  void process(size_t n, int num[5])  // 배열의 길이를 매개변수로 받는다.
  {                         
    size_t i;
    for (i = 0; i < 5; ++i)
    {
      nums[i] *= 2;   
    }                 
  }
  ```
- 배열 요소의 초기화
  - C는 배열 소의 값을 초기화해주지 않음
  - 따라서 그 전에 그 메모리에 남아있던 값을 그래도 사용
  ```c
  int nums1[4];                       // 쓰레기만 잔뜩
  int nums2[4] = { 10, 15, 3, -1 };   // 모두 초기화 됨
  int nums3[4] = { 10, 15 };          // 10, 15, 0, 0
  int nums4[2] = { 10, 15, 3 };       // 컴파일 오류
  int nums5[] = { 10, 15, 3 };        // 배열의 크기 = 3, 컴파일러가 배열의 크기를 결정
  int nums6[10] = {0, };              // 배열의 모든 값을 0으로 초기화
  ```
- 초기화 안 된 지역 변수를 모른 채 사용할 수 있는 버퍼 오버플로도 가능하다
- 그래서 C는 위험하다.
```c
int buffer[2] = {2, 2};
int buffer2[2] = {1, 1};
size_t i;

for (i = 0; i <= 2; ++i)
{
  buffer2[i] = 0;   // for 0, 1, 2
}                   // buffer2[2] 배열 범위를 벗어나 
                    // memory stomp가 일어난다.
```
- 다차원 배열 : C에서는 int[][]
  - 이 두 배열은 같음!
  ```c
  // 2차원 배열
  int buffer[3][2];  // 1,2/ 3,4/ 5,6
  int i;
  int j;
  
  for(i = 0; i < 3; ++i)
  {
    for(j = 0; j < 2; ++j)
    {
      buffoer[i][j] = 0;
    }
  }
  ```
  ```c
  // 1차원 배열
  int buffer[3 * 2];  // 1,2/ 3,4/ 5,6
  int i;
  int j;
  
  for(i = 0; i < 3; ++i)
  {
    for(j = 0; j < 2; ++j)
    {
      buffoer[i * 2 + j] = 0; //  1,2/ 3,4/ 5,6
    }
  }
  ```
































